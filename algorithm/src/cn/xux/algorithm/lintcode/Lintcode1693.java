package cn.xux.algorithm.lintcode;

import java.util.LinkedList;
import java.util.Queue;

/**
 * 1693. 小财迷走迷宫
 * cat-only-icon
 * CAT 专属题目
 * 中文English
 * 给定一个 n * m 的迷宫 maze, 其中:
 * . 表示空地
 * S 表示起点
 * T 表示终点
 * * 表示障碍物
 * 0~9 表示不同的宝物
 * 请问从起点开始, 在拿到所有宝物之后走到终点, 最少需要多少步? 如果无法拿到全部的宝物并走到终点, 返回 -1.
 *
 * 样例
 * 样例 1:
 * 输入：["T1S.",".*0*","....","..*."]
 * 输出：4
 * 解释：(0,2)->(1,2)->(0,2)->(0,1)->(0,0)
 * 样例 2:
 *
 * 输入：["1*S.","..0.","T..."]
 * 输出：6
 * 解释：(0,2)->(1,2)->(1,1)->(1,0)->(0,0)->(1,0)->(2,0)
 * 注意事项
 * n, m <= 50
 * 迷宫中的数字是连续的, 并且从 0 开始. 每个数字最多出现一次.
 * 地图上除了障碍物以外的所有点都可以行走.
 * 在收集完所有宝物之前, 终点可以被当做空地.
 */
public class Lintcode1693 {

    public static void main(String[] args) {
        System.out.println(new Lintcode1693().minSteps(new String[]{"..................................................","........*......*..............*..................*","....*.............................................","....................*......................*......","................................*.*...............","..................................................","..........*.......................................","...........*......................................","..................................................","...................*..............................","...................*..............................","...........1......................................",".....*.....................................*......","...............S..................................","...............................*........*.........","..................................................","..................................................","..................................................","..................................................","..................................................","..................................................","..................................................","..*...............................................","..................................................","..................................................","..................................................",".............*...*.................*..............",".....................*......................*.....",".*....................................*...........",".................*................................","..................*...............................","..................................................","...............*.......*..........................","..................................................","....................................*.............","..*..................*............................","..........*..................0....................",".4*....................................2..........","..........................*.......................","..................................................","..................................................","..................................................","........................................*.........",".......*..........................................","..................................................","..................................................","..................................................","..................................................",".*...................................*............","................T............................3...."}));
    }

    String[] maze;
    int m;
    int n;

    //startDis[i]表示宝物i和起点之间的最短步数
    int[] startDis;
    //endDis[i]表示宝物i和终点之间的最小步数
    int[] endDis;
    //tarsDis[i][j]表示宝物i和宝物j之间的最短步数
    int[][] tarsDis;

    /**
     * @param maze: the map
     * @return: output the minimal number of steps you will take
     */
    public int minSteps(String[] maze) {
        // Write your code here
        if(maze==null||maze.length==0||maze[0].length()==0) {
            return 0;
        }
        //init
        m = maze.length;
        n = maze[0].length();
        //起点
        int[] start = new int[2];
        //终点
        int[] end = new int[2];
        //宝物数量
        int tarCnt = 0;
        // tars[i]表示宝物i的位置
        int[][] tars = new int[10][2];
        this.maze = maze;
        for(int i=0;i<m;i++) {
            for(int j=0;j<n;j++) {
                if(maze[i].charAt(j)=='S') {
                    start[0] = i;
                    start[1] = j;
                }else if(maze[i].charAt(j)=='T') {
                    end[0] = i;
                    end[1] = j;
                }else if(maze[i].charAt(j)>='0'&&maze[i].charAt(j)<='9') {
                    tars[maze[i].charAt(j)-'0'][0] = i;
                    tars[maze[i].charAt(j)-'0'][1] = j;
                    tarCnt++;
                }
            }
        }
        startDis = new int[tarCnt];
        endDis = new int[tarCnt];
        tarsDis = new int[tarCnt][tarCnt];
        for(int i=0;i<tarCnt;i++) {
            startDis[i] = minDis(start, tars[i]);
            if(startDis[i]==-1) {
                return -1;
            }
            endDis[i] = minDis(end, tars[i]);
            if(endDis[i]==-1) {
                return -1;
            }
            for(int j=i+1;j<tarCnt;j++) {
                tarsDis[i][j] = minDis(tars[i], tars[j]);
                if(tarsDis[i][j]==-1) {
                    return -1;
                }
                tarsDis[j][i] = tarsDis[i][j];
            }
        }
        return dfs(-1, new boolean[tarCnt], tarCnt);
    }

    //广度遍历，从s点到e点的最小步数
    private int minDis(int[] s,int[] e) {
        if(s[0]==e[0]&&s[1]==e[1]) {
            return 0;
        }
        Queue<int[]> queue= new LinkedList<>();
        queue.offer(s);
        boolean[][] visited = new boolean[m][n];
        visited[s[0]][s[1]] = true;
        int step = 0;
        int[][] neis = new int[][]{{-1,0},{1,0},{0,-1},{0,1}};
        while(!queue.isEmpty()) {
            int size = queue.size();
            while(size-->0) {
                int[] curr = queue.poll();
                for(int[] nei : neis) {
                    int[] next = new int[]{curr[0]+nei[0], curr[1]+nei[1]};
                    if(next[0]>=0&&next[0]<m&&next[1]>=0&&next[1]<n
                            &&!visited[next[0]][next[1]]&&maze[next[0]].charAt(next[1])!='*') {
                        if(next[0]==e[0]&&next[1]==e[1]) {
                            return step+1;
                        }else {
                            visited[next[0]][next[1]] = true;
                            queue.offer(next);
                        }
                    }
                }
            }
            step++;
        }
        return -1;
    }

    //从宝物idx(=-1时表示起点S)遍历完剩下的所有宝物并到达终点的最小步数
    private int dfs(int idx, boolean[] visited, int k) {
        if(k==0) {
            return endDis[idx];
        }
        int ans = Integer.MAX_VALUE;
        for(int i=0;i<visited.length;i++) {
            if(!visited[i]) {
                visited[i] = true;
                int postAns = dfs(i, visited, k-1);
                ans = Math.min(ans, postAns+(idx==-1?startDis[i]:tarsDis[idx][i]));
                visited[i] = false;
            }
        }
        return ans;
    }

}
